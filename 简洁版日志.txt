/***************************************LLDP*****************************************/
1.LLDP简介
LLDP：链路层发现协议的简称，几乎所有以太网交换机都内置了这个功能。通过采用LLDP技术，在网络规模迅速扩大时，网管系统可以快速掌握二层
网络拓扑信息和拓扑变化信息。	

2.LLDP原理如下：
a.交换机定期通过LLDP报文对外广播自己的设别类型、端口编号等信息，交换机不会转发lldp报文，但是会在链路上侦听其他设备发送过来的lldp数据，
并在一定时限的有效期内存储在在交换机MIB中，可以供SNMP查询，进而掌握自己邻居的大致情况。
b.LLDP报文数据段是以TLV的格式定义的，分别说明了数据是哪方面信息，长度以及本身的内容。

总体来说LLDP主要工作有以下几个方面：
•  初始化并维护本地 MIB库中的信息。 
•  从本地MIB库中提取信息，并将信息封装到LLDP帧中，以一定的时间间隔或者当设备状态发生变化时，将LLDP帧发送出去，通告邻接设备。 
•  对收到的LLDP帧进行确认和处理。 
•  通过收到的LLDP帧维护远端设备LLDP MIB信息库。 
•  当Local System MIB或Remote System MIB中有信息发生变化时，向网管上报。



/***************************************netconf*****************************************/
1.netconf（The Network Configuration Protocol）可以理解为一种通用的协议，为网管和设备之间提供了一套协议，网管通过netconf协议可以实现本地管理，对远端设备的配置进行下发，
修改和删除等操作。(Yang是netconf协议的一种数据建模语言)

2.交换机上的netconf实现：
a.VRP进程：交换机各种转发业务，对外提供命令行界面
b.RPA进程：python实现的NETCONF协议南向进程
c.Confd进程：NETCONF协议解析者，NETCONF协议引擎

3.	Sysname是如何下发的？
需要注意的是，由于VRP是交换机的业务主体，因此修改sysname的操作实际是从VRP进程中生效。让我们回想NETCONF的整体概念图，可知sysname的下发分如下几步：
a)	yangsh(NETCONF client)中，响应commit命令，发现sysname发生变化。yangsh将变化组织为符合NETCONF协议的XML报文，发送至confd进程
b)	confd进程解析收到的NETCONF协议报文，并与数据库中的配置比对，发现sysname发生变更。
c)	confd检索关注/huawei-device:device/name节点变更的南向plugin，发现RPA关注此变更。通知RPA进程节点变更事件。
d)	RPA收到此节点变更事件后，与confd进行多次交互，得知sysname变化为HUAWEI-F5。
e)	RPA进程中调用具体的plugin实现，并将sysname变更的xml作为参数传递给plugin。
f)	plugin解析此变化，并把sysname组织成命令行sysname HUAWEI-F5配置到VRP进程，同时将结果返回。
g)	RPA进程收到plugin的返回结果，再将结果通知给confd进程。
h)	confd进程根据RPA的结果刷新数据库，并将结果组织成标准的NETCONF协议发回yangsh
i)	yansh显示出成果的消息。

4.netconf协议框架：
a.传输层(BEEP,SSH,SSL协议)
b.RPC层(<rpc>,<rpc-reply>)
c.操作层（<get-config>,<edit-config>,<notification>)
d.内容层(配置数据)

5.网管与交换机通过netconf协议进行通信的交互流程：
a.交换机与网管建立SSH连接。(SSH:secure shell建立在应用层和传输从基础之上的安全协议，可以有效防止远程管理过程中的信息泄露问题)
b.交换机与网管通过Hello报文交换双方支持的能力。
c.网管与交换机建立NETCONF会话后，即可发送RPC操作请求至交换机，进行配置管理。
d.交换机对收到的RPC操作请求进行解析与处理，并发送RPC应答给网管。
e.操作完成后，网管可以发送关闭NETCONF会话的RPC请求，以节省交换机和网管不必要的资源开销。
f.交换机关闭NETCONF会话，并发送RPC应答给网管。



/***************************************TCP/IP*****************************************/
1.TCP/IP网络管理协议标准可以分为三大部分：
SNMP为简单的网络管理协议，属于TCP/IP五层协议中的应用层协议。
SNMP的基本思想：为不同种类的设备、不同厂家生产的设备、不同型号的设备，定义为一个统一的接口和协议，使得管理员可以使用统一
的外观面对这些需要管理的网络设备进行管理。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高了网络管理效率，简化
网络管理工作。
SNMP的工作方式：管理员需要向设备获取数据，所以SNMP提供了读操作。
管理员需要向设备执行设置操作，所以SNMP提供了写操作。
设备需要在重要状况改变的时候，向管理员通报事件的发生，所以SNMP提供了TRAP操作。

2.MIB（management information base）：可以理解为agent维护的管理对象数据库，MIB中定义的大部分管理对象的状态和统计信息都
可以被NMS访问。
MIB是一个被管理对象的集合，它定义被管理对象的一系列属性，包括：
对象的名字
对象的访问权限
对象的数据类型



/***************************************代码头文件目录*****************************************/
代码中头文件所在目录默认为：code/product这个目录


/***************************************云盒上线基本流程*****************************************/


		堆叠系统							云管理平台
堆叠系统切换为云管理模式		

主交换机向云管理平台注册

								查询堆叠系统状态信息（单机还是堆叠）


发送主交换机系统状态信息

								对比堆叠系统状态和云管理平台设置状态（状态一致，主交换机注册成功，状态不一致，主交换机注册失败）


主交换机注册成功后，上报成员交换机信息

								成员交换机配置比对通过，成员交换机设置注册成功，若槽号不一致，则重启交换机，重新注册



								
/***************************************CMO*****************************************/
命令的分析是一个准备工作，目的在于分析出如何最简单的区分出你所有添加的命令，也就是命令定位。系统定位一条完整命令
是通过 模块——>表——>CMO 这样一层一层定位的，模块不用说，表可以看做是分类的，把命令字分成不同的类,而CMO就是表内的索引。
比如下面的例子假如你要加入这四条命令：a b c、a b d、e f、e h，你可以把前两个分在一个表中，后两个分在另一个表中。
CMO是用来区分同一个表中的不同命令元素的，这里就可以分别给 c,d,f,h定义CMO。
命令行开发的步骤：
a.注册命令处理回调函数 					b.添加CMO    （eg:CFG_CMO_DEF(PID_NETCONF,CMOTBL_NTCF_NTF,1)中分别表示模块号，表号，索引号
													模块号即是本模块，表号为自己申请，比如在CMO上面定义CMOTBL_NTCF_NTF=0X01,索引号
													 代表的是之后命令安装时候用到的$1 $2 $3，将注册的不同命令联系起来）
c.定义元素								d.安装命令
e.注册命令

具体看2019.6月自我总结的 个人版本命令行注册   公司版本-命令行注册word




/***************************************MIB查找*****************************************/
主要在两个文件中entitymib_tree.c
				entityextmib_tree.c
				
有关端口信息的在entPhysicalName中，根据CMO去定位问题。
根据不同的CMO分支，会进入不同的函数


/***************************************变量后面用：*****************************************/
该种形式出现于结构体或共用体的定义中，是位域定义的标准形式。
其使用方式为
struct name
{
type var_name : n;
};
含义为，在结构体name汇总，成员变量var_name占用空间为n位。
n为正整数，其值必须小于type类型占用的位数。比如type如果是int，占4字节32位，那么n必须是1~31之间的整数。
对于位域类型的成员，在赋值时如果实际值超过n位所能表达的范围，那么超出部分将会被截掉，只保存低位值。
如int var:4,本身只有4位的空间，如果赋值var = 20, 由于20的二进制值为10100，实际为五位，这时var实际被赋值的就是低四位，0100，即4。
由于C语言中的地址是针对字节计算的，所以位域类型的成员变量不支持取地址操作，即对于变量v, 如果存在位域成员变量var，那么&a.var是非法的，编译会出错。


/***************************************IFNET功能*****************************************/
1.IFNET主要功能之一是对系统中的各种接口进行操作和管理（接口创建、删除、查找、属性设置），主要通过命令行的方式实现。
2.IFNET另一个主要功能是实现报文和控制信息在网络层、链路层和物理层之间的传递。



/***************************************环境配置SNMP*****************************************/
<HUAWEI>sys                                                                                                                         
Enter system view, return user view with Ctrl+Z.                                                                                    
[HUAWEI]snmp-agent                                                                                                                  
[HUAWEI]snmp-agent  sys-info version all                                                                                            
Warning: SNMPv1/SNMPv2c is not secure, and it is recommended to use SNMPv3.                                                         
[HUAWEI]snmp-agent community read huawei123                                                                                         
[HUAWEI]snmp-agent community write huawei123


/***************************************PIC卡*****************************************/
框/槽/子卡/端口   都是以父节点往下拓宽的，要查看端口号，就得从子卡上获取。



/***************************************输出显示*****************************************/
如果输出方式是EXEC_OutString或类似这种，通过获取UserId来输出的，两者显示一样
如果是printf类似显示，只显示到串口上



